{
  "data": [
    {
      "answermd": "### 方法一\n\n正则表达式\n\n```js\nexport default function amountThousandthsFormat(amount) {\n  return amount.replace(/(?<!\\.\\d*)\\B(?=(?:\\d{3})+\\b)/, ',');\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "amountThousandthsFormat",
      "answer": "export default function f(amount) {\n  return amount.replace(/(?<!\\.\\d*)\\B(?=(?:\\d{3})+\\b)/g, ',');\n}\n",
      "introduce": "金额千分位格式化\n\n用例 1:\n\n```js\nconst amount = '314';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '314'\n```\n\n用例 2:\n\n```js\nconst amount = '31415926';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926'\n```\n\n用例 3:\n\n```js\n// 带小数位\nconst amount = '31415926.62';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.62'\n```\n\n用例 4:\n\n```js\n// 带长小数位\nconst amount = '31415926.629514';\nconst formatAmount = amountThousandthsFormat(amount);\n\nconsole.log(formatAmount); // '3,415,926.629514'\n```\n",
      "desc": "金额千分位格式化",
      "template": "/**\n * 金额千分位格式化\n *\n * @param {*} amount\n * @return {*}\n */\nexport default function amountThousandthsFormat(amount) {\n  return amount;\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('无需格式化-原样输出: 输入 314', () => {\n  assert.deepEqual(f('314'), '314');\n});\n\nit('输入 31415926', () => {\n  assert.deepEqual(f('31415926'), '31,415,926');\n});\n\nit('带小数位: 输入 31415926.62', () => {\n  assert.deepEqual(f('31,415,926.62'), '31,415,926.62');\n});\n\nit('带长小数位: 输入 31415926.629514', () => {\n  assert.deepEqual(f('31,415,926.629514'), '31,415,926.629514');\n});\n"
    },
    {
      "answermd": "### 方法一\n\n拆解分析, 只有两个中间件的情况\n\n每个中间件为前一个中间件的参数\n\n```js\nconst compose = (m1, m2) => {\n  return (x) => {\n    return m1(m2(x));\n  };\n};\n```\n\nreduce 组合中间件函数\n\n```js\nexport default function compose(...args) {\n  if (args.length === 0) return (x) => x;\n  if (args.length === 1) return args[0];\n  return args.reduce(\n    (acc, cur) =>\n      (...args) =>\n        acc(cur(...args))\n  );\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "compose",
      "answer": "export default function compose(...args) {\n  if (args.length === 0) return (x) => x;\n  if (args.length === 1) return args[0];\n  return args.reduce(\n    (acc, cur) =>\n      (...args) =>\n        acc(cur(...args))\n  );\n}\n",
      "introduce": "实现 compose 函数\n\n在 Koa 洋葱模型中, 我们希望每个请求经过几层中间件的处理, 例如 跨域中间件, 鉴权中间件, 日志中间件\n\n<img src=\"https://image.xjq.icu/2022/11/22/1669046983667_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221122000922.png\" />\n\n我们需要编写一个 compose 函数, 将中间件以数组参数传入方式转化为 函数嵌套的形式\n\n中间件为纯函数的情况下\n\n例: 将 [a,b,c] 转换为 a(b(c(...args)))\n\nKoa 中间件为 闭包函数\n\n例: 将 [a,b,c] 转换为 a(b(c(final)))(initial)\n\n用例 1:\n\n无中间件\n\n```js\ncompose()(5); // 5\n```\n\n用例 2:\n\n中间件为纯函数\n\n```js\nconst double = (x) => x * 2;\nconst square = (x) => x * x;\n\n// 先平方计算再乘法计算\ncompose(double, square)(10); // 200\n```\n\n用例 3:\n\n中间件为闭包函数\n\n```js\n// a(b(c(final)))(initial)\n\nconst a = (next) => (x) => next(x + 'a');\nconst b = (next) => (x) => next(x + 'b');\nconst c = (next) => (x) => next(x + 'c');\nconst final = (x) => x;\n\ncompose(a, b, c)(final)(''); // abc\n```\n",
      "desc": "实现 compose 函数",
      "template": "/**\n * compose\n *\n * @export\n * @param {Function[]} middleware\n * @return {Function}\n */\nexport default function compose(middleware) {\n  return () => {};\n}\n",
      "test": "import compose from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nconst double = (x) => x * 2;\nconst square = (x) => x * x;\n\nit('用例 1: 输入 compose()(5)', () => {\n  assert.equal(compose()(5), 5);\n});\n\nit('用例 2: 输入 compose(double, square)(10)', () => {\n  assert.equal(compose(double, square)(10), 200);\n});\n\nit('用例 3: 输入 compose(square, double)(5)', () => {\n  assert.equal(compose(square, double)(5), 100);\n});\n\nit('用例 4: 输入 compose(double, square)(final)(5)', () => {\n  const double = (next) => (x) => next(x * 2);\n  const square = (next) => (x) => next(x * x);\n  const final = (x) => x;\n  assert.equal(compose(double, square)(final)(5), 100);\n});\n\nit(\"用例 5: 输入 compose(a, b, c)(final)('')\", () => {\n  const a = (next) => (x) => next(x + 'a');\n  const b = (next) => (x) => next(x + 'b');\n  const c = (next) => (x) => next(x + 'c');\n  const final = (x) => x;\n  assert.equal(compose(a, b, c)(final)(''), 'abc');\n});\n"
    },
    {
      "answermd": "### 方法一\n\n通过闭包函数存储参数, 待到无参传递时调用 fn 函数,并将全部参数传递给 fn 函数\n\n```js\nexport default function currying(fn) {\n  let _args = [];\n  return (...args) => {\n    let result = null;\n    if (args.length) {\n      _args = _args.concat(args);\n    } else {\n      result = fn(..._args);\n    }\n    return result;\n  };\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "curry",
      "answer": "export default function f(fn) {\n  let _args = [];\n  return (...args) => {\n    let result = null;\n    if (args.length) {\n      _args = _args.concat(args);\n    } else {\n      result = fn(..._args);\n    }\n    return result;\n  };\n}\n",
      "introduce": "实现一个柯里化函数\n\n柯里化函数是将接收多个参数的函数变换成一个接收单一参数的函数,并且返回一个接收余下参数并返回结果的新函数\n\n例: 延迟执行\n\nurl 拼接\n\n```js\nconst curringUrl = curring((...args) => args.reduce((acc, cur) => acc + cur));\n\ncurringUrl('https://');\ncurringUrl('r.xjq.icu');\ncurringUrl(); // https://r.xjq.icu\ncurringUrl('/question');\ncurringUrl('?name=curry');\ncurringUrl(); // https://r.xjq.icu/question?name=curry\n```\n\n请实现一个延迟执行的柯里化函数, 最终无参数传递时真正调用\n\n用例 1:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1], [2], [3], null]\n\n// 执行\nconst curryAdd = currying(add); // true\ncurryAdd(1); // null\ncurryAdd(2); // null\ncurryAdd(3); // null\ncurryAdd(); // 6\n\n// [true, null, null, null, 6]\n```\n\n用例 2:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1, 2, 1], null, null, null]\nconst curryAdd = currying(add); // true\ncurryAdd(1, 2, 1); // null\ncurryAdd(); // 4\ncurryAdd(); // 4\ncurryAdd(); // 4\n\n// [true, null, 4, 4, 4]\n```\n\n用例 3:\n\n```js\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\n\n// 输入 [add, [1, 2, 1], null, [1, 2], null]\nconst curryAdd = currying(add); // true\ncurryAdd(1, 2, 1); // null\ncurryAdd(); // 4\ncurryAdd(1, 2); // null\ncurryAdd(); // 7\n\n// [true, null, 4, null, 7]\n```\n\n用例 4:\n\n```js\nconst multi = (...args) => args.reduce((a, b) => a * b, 1);\n\n// 输入 [multi, [100], null, [1, 2], null]\nconst curryMulti = currying(multi);\ncurryMulti(100); // null\ncurryMulti(); // 100\ncurryMulti(1, 2); // null\ncurryMulti(); // 200\n// [true, null, 100, null, 200]\n```\n",
      "desc": "实现一个柯里化函数",
      "template": "/**\n * 柯里化函数\n *\n * @export\n * @param {Function} fn\n * @return {Function}\n */\nexport default function curry(fn) {\n  return fn;\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nconst add = (...args) => args.reduce((a, b) => a + b, 0);\nconst multi = (...args) => args.reduce((a, b) => a * b, 1);\n\nfunction Received(Input) {\n  let curry;\n  const output = [];\n  Input.forEach((arg) => {\n    let result;\n    if (!curry) {\n      curry = f(arg);\n      result = !!curry;\n    } else if (arg) {\n      result = curry(...arg);\n    } else {\n      result = curry();\n    }\n    output.push(result);\n  });\n  return output;\n}\n\nit('加法函数柯里化一: 输入 [add, [1], [2], [3], null]', () => {\n  assert.deepEqual(Received([add, [1], [2], [3], null]), [\n    true,\n    null,\n    null,\n    null,\n    6,\n  ]);\n});\n\nit('加法函数柯里化二: 输入 [add, [1, 2, 1], null, null, null]', () => {\n  assert.deepEqual(Received([add, [1, 2, 1], null, null, null]), [\n    true,\n    null,\n    4,\n    4,\n    4,\n  ]);\n});\n\nit('加法函数柯里化三: 输入 [add, [1, 2, 1], null, [1, 2], null]', () => {\n  assert.deepEqual(Received([add, [1, 2, 1], null, [1, 2], null]), [\n    true,\n    null,\n    4,\n    null,\n    7,\n  ]);\n});\n\nit('乘法函数柯里化一: 输入 [multi, [100], null, [1, 2], null]', () => {\n  assert.deepEqual(Received([multi, [100], null, [1, 2], null]), [\n    true,\n    null,\n    100,\n    null,\n    200,\n  ]);\n});\n"
    },
    {
      "answermd": "### 方法一\n\n递归拷贝, 使用 weakMap 过滤循环引用\n\n```js\nexport default function deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "deepClone",
      "answer": "export default function deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n",
      "introduce": "实现对象深拷贝, 修改深拷贝对象不影响原对象\n\n用例 1:\n\n```js\nconst userList = { user: [{ name: 'xjq' }] };\nconst cloneUserList = deepClone(userList);\n\nconsole.log(cloneUserList); // { user: [{ name: 'xjq' }] }\ncloneUserList.user.push({ name: 'xjq1' });\nconsole.log(cloneUserList.user); // [{ name:'xjq' }]\n```\n\n用例 2:\n\n```js\n\nconst user = { name: 'xjq', height: 180 };\nconst cloneUser = deepClone(user);\n\nconsole.log(user); // { name: 'xjq', height: 180 }\n\ndelete cloneUser.height;\nconsole.log(cloneUser); // { name: 'xjq' }\nconsole.log(user; // { name: 'xjq', height: 180 }\n```\n",
      "desc": "实现对象深拷贝, 修改深拷贝对象不影响原对象",
      "template": "/**\n * 深拷贝\n *\n * @param {(Array|Object)} obj\n * @return {(Array|Object)}\n */\nexport default function deepClone(obj) {\n  return {};\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('一层对象: 输入 { f: 2 }', () => {\n  assert.deepEqual(f({ f: 2 }), { f: 2 });\n});\n\nit('两层对象: 输入 { a: 1, b: { c: 3 } }', () => {\n  assert.deepEqual(f({ a: 1, b: { c: 3 } }), { a: 1, b: { c: 3 } });\n});\n\nit('数组: 输入 [1, { a: 1 }]', () => {\n  assert.deepEqual(f([1, { a: 1 }]), [1, { a: 1 }]);\n});\n\nit('修改拷贝对象属性, 原对象应不受影响', () => {\n  const Input = { b: { c: 1, d: 2 } };\n  const cloneObj = f(Input);\n  cloneObj.b.c = 2;\n  assert.deepEqual(Input, {\n    b: { c: 1, d: 2 },\n  });\n});\n\nit('循环引用', () => {\n  const circle1 = { foo: 1 };\n  const circle2 = { bar: 2, c1: circle1 };\n  circle1.c2 = circle2;\n  assert.deepEqual(f(circle1), { foo: 1, c2: { bar: 2, c1: {} } });\n});\n"
    },
    {
      "answermd": "### 方法一\n\n递归处理\n\n```js\nfunction getType(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n\nexport default function deepMerge(a, b) {\n  if (getType(a) !== '[object Object]' && getType(a) !== '[object Array]') {\n    return deepClone(b);\n  }\n\n  const isArray = getType(a) === '[object Array]';\n  const res = isArray ? [] : {};\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      res[key] = deepMerge(a[key], b[key]);\n    }\n  }\n  for (const key in a) {\n    if (res[key] === undefined && a.hasOwnProperty(key)) {\n      res[key] = deepClone(a[key]);\n    }\n  }\n  return res;\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "deepMerge",
      "answer": "function getType(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction deepClone(obj, weakMap = new WeakMap()) {\n  const type = Object.prototype.toString.call(obj);\n  if (!(type === '[object Object]' || type === '[object Array]')) return obj;\n  const o = type === '[object Object]' ? {} : [];\n  if (weakMap.get(obj)) return o;\n  weakMap.set(obj, true);\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      o[key] = deepClone(obj[key], weakMap);\n    }\n  }\n  return o;\n}\n\nexport default function deepMerge(a, b) {\n  if (getType(a) !== '[object Object]' && getType(a) !== '[object Array]') {\n    return deepClone(b);\n  }\n\n  const isArray = getType(a) === '[object Array]';\n  const res = isArray ? [] : {};\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      res[key] = deepMerge(a[key], b[key]);\n    }\n  }\n  for (const key in a) {\n    if (res[key] === undefined && a.hasOwnProperty(key)) {\n      res[key] = deepClone(a[key]);\n    }\n  }\n  return res;\n}\n",
      "introduce": "对象合并\n\n深度合并两个对象可枚举属性, 并且修改新对象不会影响原对象, 相同的属性则以 b 对象为主\n\n用例 1:\n\n```js\nconst a = { a: 1 };\nconst b = { b: 2 };\n\ndeepMerge(a, b); // { a: 1, b: 2 }\n```\n\n用例 2:\n\n```js\nconst a = { foo: { bar: 0 }, arr: [1, 3, { a: { b: 1 } }] };\nconst b = { foo: { bar: 1 }, arr: [1, 2, { b: { a: 1 } }] };\n\ndeepMerge(a, b); // { foo: { bar: 1 }, arr: [1, 2, { a: { b: 1 }, b: { a: 1 } }] }\n```\n\n用例 3:\n\nb 属性值为 undefined 不会并入 a\n\n```js\nconst a = { a: 1 };\nconst b = { a: undefined };\n\ndeepMerge(a, b); // { a: 1 }\n```\n\n用例 4:\n\n```js\nconst a = { a: 1 };\nconst b = undefined;\n\ndeepMerge(a, b); // { a: 1 }\n```\n\n用例 5:\n\n```js\nconst a = undefined;\nconst b = { a: 1 };\n\ndeepMerge(a, b); // { a: 1 }\n```\n",
      "desc": "对象合并",
      "template": "/**\n * 对象合并\n *\n * @export\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n */\nexport default function deepMerge(a, b) {\n  return {};\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('一层对象: 输入 { a: 1 }, { b: 2 }', () => {\n  assert.deepEqual(f({ a: 1 }, { b: 2 }), { a: 1, b: 2 });\n});\n\nit('两层对象: 输入 { a: 1, b: { c: 2 } }, { b: 2 }', () => {\n  assert.deepEqual(f({ a: 1, b: { c: 2 } }, { b: { c: 3, d: 4 } }), {\n    a: 1,\n    b: { c: 3, d: 4 },\n  });\n});\n\nit(\"两层对象存在数组合并: 输入 { b: { c: [1, 3, { a: 1 }] } }, { b: { c: ['1', 2, { a: 2 }] } }\", () => {\n  assert.deepEqual(\n    f({ b: { c: [1, 3, { a: 1 }] } }, { b: { c: ['1', 2, { a: 2 }] } }),\n    { b: { c: ['1', 2, { a: 2 }] } }\n  );\n});\n\nit('b 中属性值为 undefined 时不会合并: 输入 { a: 1 }, { a: undefined }', () => {\n  assert.deepEqual(f({ a: 1 }, { a: undefined }), { a: 1 });\n});\n\nit('边界输入一 undefined | null, { a: 1 }', () => {\n  assert.deepEqual(f(undefined, { a: 1 }), { a: 1 });\n  assert.deepEqual(f(null, { a: 1 }), { a: 1 });\n});\n\nit('边界输入二 { a: 1 }, undefined | null', () => {\n  assert.deepEqual(f({ a: 1 }, undefined), { a: 1 });\n  assert.deepEqual(f({ a: 1 }, null), { a: 1 });\n});\n"
    },
    {},
    {
      "answermd": "### 方法一\n\n```js\nexport default function flatten(arr) {\n  return arr.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      acc = acc.concat(flatten(cur));\n    } else {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "flatten",
      "answer": "export default function flatten(arr) {\n  return arr.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      acc = acc.concat(flatten(cur));\n    } else {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n",
      "introduce": "实现数组扁平化方法\n\n用例 1:\n\n```js\nflatten([1, 2, 3]); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nflatten([1, [2, 3]]); // [1, 2, 3]\n```\n\n用例 3:\n\n```js\nflatten([1, [[2, 2], [3, [4]], 5]]); // [1, 2, 2, 3, 4, 5];\n```\n",
      "desc": "实现数组扁平化方法",
      "template": "/**\n * 数组扁平化\n *\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function flatten(arr) {\n  return [];\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('一层数组: 输入 [1, 2, 3]', () => {\n  assert.deepEqual(f([1, 2, 3]), [1, 2, 3]);\n});\n\nit('两层数组: 输入 [1, [2, 3]]', () => {\n  assert.deepEqual(f([1, [2, 3]]), [1, 2, 3]);\n});\n\nit('四层数组: 输入 [1, [[2, 2], [3, [4]], 5]]', () => {\n  assert.deepEqual(f([1, [[2, 2], [3, [4]], 5]]), [1, 2, 2, 3, 4, 5]);\n});\n"
    },
    {
      "answermd": "### 方法一\n\n递归处理\n\n子节点不为空的时候, 递归遍历并拼接至当前结果之后\n\n```js\nexport default function flattenTree(tree) {\n  return tree.reduce((acc, cur) => {\n    const { id, children } = cur;\n    acc.push(id);\n    if (children && children.length) {\n      acc = acc.concat(flattenTree(children));\n    }\n    return acc;\n  }, []);\n}\n```\n\n### 方法二\n\n栈\n\n```js\nexport default function flattenTree(tree) {\n  const stack = [...tree.reverse()];\n  const ans = [];\n\n  while (stack.length) {\n    const top = stack[stack.length - 1];\n    stack.pop();\n    ans.push(top.id);\n    if (top.children && top.children.length) {\n      stack.push(...top.children.reverse());\n    }\n  }\n  return ans;\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "flattenTree",
      "answer": "/**\n * interface TreeNode{\n *    id: number;\n *    children: TreeNode[]\n * }\n *\n * @export\n * @param {TreeNode[]} tree\n * @return {number[]}\n */\nexport default function flattenTree(tree) {\n  const stack = [...tree.reverse()];\n  const ans = [];\n\n  while (stack.length) {\n    const top = stack[stack.length - 1];\n    stack.pop();\n    ans.push(top.id);\n    if (top.children && top.children.length) {\n      stack.push(...top.children.reverse());\n    }\n  }\n  return ans;\n}\n",
      "introduce": "扁平化一棵树\n\n输入一棵树, 输出书中 id 的扁平集合\n\n用例 1:\n\n```js\nconst tree1 = [\n  {\n    id: 0,\n    children: [\n      {\n        id: 1,\n        children: [\n          {\n            id: 2,\n            children: [],\n          },\n        ],\n      },\n      {\n        id: 3,\n        children: [],\n      },\n    ],\n  },\n  {\n    id: 4,\n    children: [],\n  },\n];\n\nflattenTree(tree1); // [0, 1, 2, 3, 4]\n```\n\n用例 2:\n\n```js\nconst tree2 = [];\nflattenTree(tree2); // []\n```\n\n用例 3:\n\n```js\nconst tree3 = [\n  {\n    id: 0,\n    children: [],\n  },\n  {\n    id: 1,\n    children: [],\n  },\n  {\n    id: 2,\n    children: [],\n  },\n  {\n    id: 3,\n    children: [],\n  },\n];\nflattenTree(tree3); // [0, 1, 2, 3]\n```\n\n用例 4:\n\n```js\nconst tree4 = [\n  {\n    id: 0,\n    children: [\n      {\n        id: 1,\n        children: [\n          {\n            id: 2,\n            children: [],\n          },\n        ],\n      },\n      {\n        id: 3,\n        children: [\n          {\n            id: 4,\n            children: [\n              {\n                id: 5,\n                children: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  },\n  {\n    id: 6,\n    children: [],\n  },\n];\nflattenTree(tree4); // [0, 1, 2, 3, 4, 5, 6]\n```\n",
      "desc": "扁平化一棵树",
      "template": "/**\n * 树的扁平化\n *\n * @export\n * @param {*} tree\n * @return {*}\n */\nexport default function flattenTree(tree) {\n  return [];\n}\n",
      "test": "import flattenTree from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nconst tree1 = [\n  {\n    id: 0,\n    children: [\n      {\n        id: 1,\n        children: [\n          {\n            id: 2,\n            children: [],\n          },\n        ],\n      },\n      {\n        id: 3,\n        children: [],\n      },\n    ],\n  },\n  {\n    id: 4,\n    children: [],\n  },\n];\n\nit('输入 tree1', () => {\n  assert.deepEqual(flattenTree(tree1), [0, 1, 2, 3, 4]);\n});\n\nconst tree2 = [];\n\nit('输入 tree2 空树', () => {\n  assert.deepEqual(flattenTree(tree2), []);\n});\n\nconst tree3 = [\n  {\n    id: 0,\n    children: [],\n  },\n  {\n    id: 1,\n    children: [],\n  },\n  {\n    id: 2,\n    children: [],\n  },\n  {\n    id: 3,\n    children: [],\n  },\n];\n\nit('输入 tree3 一颗只有一层节点的树', () => {\n  assert.deepEqual(flattenTree(tree3), [0, 1, 2, 3]);\n});\n\nconst tree4 = [\n  {\n    id: 0,\n    children: [\n      {\n        id: 1,\n        children: [\n          {\n            id: 2,\n            children: [],\n          },\n        ],\n      },\n      {\n        id: 3,\n        children: [\n          {\n            id: 4,\n            children: [\n              {\n                id: 5,\n                children: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  },\n  {\n    id: 6,\n    children: [],\n  },\n];\n\nit('输入 tree4', () => {\n  assert.deepEqual(flattenTree(tree4), [0, 1, 2, 3, 4, 5, 6]);\n});\n"
    },
    {
      "answermd": "### 方法一\n\nKMP 算法\n\n```js\n// 子串 next 数组\nfunction next(substr) {\n  const _next = new Array(substr.length).fill(0);\n  let j = -1,\n    i = 0;\n\n  while (i < substr.length) {\n    if (j == -1 || substr[i] == substr[j]) {\n      j++;\n      i++;\n      _next[i] = j;\n    } else {\n      j = -1;\n    }\n  }\n  return _next;\n}\n\nexport default function Kmp(str, substr) {\n  let i = 0,\n    j = 0;\n  const _next = next(substr);\n  while (i < str.length && j < substr.length) {\n    if (str[i] == substr[j]) {\n      i++;\n      j++;\n    } else if (j != 0) {\n      j = _next[j];\n    } else {\n      i++;\n    }\n  }\n  return j == substr.length ? i - j : -1;\n}\n```\n\n### 方法二\n\nindexOf API\n\n```js\nexport default function indexOf(str, substr) {\n  return str.indexOf(substr);\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "indexOf",
      "answer": "// 子串 next 数组\nfunction next(substr) {\n  const _next = new Array(substr.length).fill(0);\n  let j = -1,\n    i = 0;\n\n  while (i < substr.length) {\n    if (j == -1 || substr[i] == substr[j]) {\n      j++;\n      i++;\n      _next[i] = j;\n    } else {\n      j = -1;\n    }\n  }\n  return _next;\n}\n\nexport default function Kmp(str, substr) {\n  let i = 0,\n    j = 0;\n  const _next = next(substr);\n  while (i < str.length && j < substr.length) {\n    if (str[i] == substr[j]) {\n      i++;\n      j++;\n    } else if (j != 0) {\n      j = _next[j];\n    } else {\n      i++;\n    }\n  }\n  return j == substr.length ? i - j : -1;\n}\n",
      "introduce": "实现字符串查找函数 indexOf\n\n用例 1:\n\n```js\nconst str = 'hello world';\n\nindexOf(str, 'l'); // 2\n```\n\n用例 2:\n\n```js\nconst str =\n  'There is magic in the trying and learning and trying again.. but any unprocessed PTSD will come back to haunt you';\n\nindexOf(str, 'PTSD'); // 81\n```\n\n用例 3:\n\n```js\nconst str = 'hello world';\n\nindexOf(str, 'ol'); // -1\n```\n",
      "desc": "实现字符串查找函数 indexOf",
      "template": "/**\n * 字符串查找\n *\n * @export\n * @param {string} str\n * @param {string} substr\n * @return {number}\n */\nexport default function indexOf(str, substr) {\n  return -1;\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit(\"用例 1: 输入 'hello world', 'l'\", () => {\n  assert.deepEqual(f('hello world', 'l'), 2);\n});\n\nit(\"用例 2: 输入 'hello world', 'ol'\", () => {\n  assert.deepEqual(f('hello world', 'ol'), -1);\n});\n\nit(\"用例 3: 输入 'hello world', 'world'\", () => {\n  assert.deepEqual(f('hello world', 'world'), 6);\n});\n\nit(\"用例 4: 输入 'hello world', ' '\", () => {\n  assert.deepEqual(f('hello world', ' '), 5);\n});\n\nit(\"用例 5: 输入 'There is magic in the trying and learning and trying again.. but any unprocessed PTSD will come back to haunt you', 'PTSD'\", () => {\n  assert.deepEqual(\n    f(\n      'There is magic in the trying and learning and trying again.. but any unprocessed PTSD will come back to haunt you',\n      'PTSD'\n    ),\n    81\n  );\n});\n\nit(\"用例 6: 输入 '', ' '\", () => {\n  assert.deepEqual(f('', ' '), -1);\n});\n"
    },
    {
      "answermd": "### 方法一\n\n正则表达式\n\n```js\nexport default function isIp(ip) {\n  return /^((2(5[0-5]|[0-4]\\d)|1\\d{2}|\\d{1,2})\\.){3}(2(5[0-5]|[0-4]\\d)|1\\d{2}|\\d{1,2})$/.test(\n    ip\n  );\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "ipAddress",
      "answer": "export default function isIp(ip) {\n  return /^((2(5[0-5]|[0-4]\\d)|1\\d{2}|\\d{1,2})\\.){3}(2(5[0-5]|[0-4]\\d)|1\\d{2}|\\d{1,2})$/.test(\n    ip\n  );\n}\n",
      "introduce": "验证 IP 地址合法性\n\n一个合法的 IP 地址 在 0.0.0.0 ~ 255.255.255.255 的范围\n\n具体的 IP 地址 分类\n\n- A 类 IP 地址 范围 0.0.0.0 ~ 127.255.255.255\n- B 类 IP 地址 范围 128.0.0.0 ~ 191.255.255.255\n- C 类 IP 地址 范围 192.0.0.0 ~ 223.255.255.255\n- D 类 Ip 地址 范围 224.0.0.0 ~ 239.255.255.255\n- E 类 IP 地址 范围 240.0.0.0 ~ 255.255.255.255\n\n用例 1:\n\n```js\nconst ip = '192.168.1.1';\n\nisIp(ip); // true\n```\n\n用例 2:\n\n```js\nconst ip = '127.0.0.1';\n\nisIp(ip); // true\n```\n\n用例 3:\n\n```js\nconst ip = '254.254.254.256';\n\nisIp(ip); // false\n```\n\n用例 4:\n\n```js\nconst ip = '255.255.255.255';\n\nisIp(ip); // true\n```\n\n用例 5:\n\n```js\nconst ip = '0.0.0.0';\n\nisIp(ip); // true\n```\n\n用例 6:\n\n```js\nconst ip = '192.168.1.-1';\n\nisIp(ip); // false\n```\n",
      "desc": "验证 IP 地址合法性",
      "template": "/**\n * 判断 IP 地址是否合法\n *\n * @export\n * @param {string} ip\n * @return {boolean}\n */\nexport default function isIp(ip) {\n  return true;\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('用例 1: 输入 127.0.0.1', () => {\n  assert.deepEqual(f('127.0.0.1'), true);\n});\n\nit('用例 2: 输入 192.168.1.1', () => {\n  assert.deepEqual(f('192.168.1.1'), true);\n});\n\nit('用例 3: 输入 0.0.0.0', () => {\n  assert.deepEqual(f('0.0.0.0'), true);\n});\n\nit('用例 4: 输入 254.254.254.256', () => {\n  assert.deepEqual(f('254.254.254.256'), false);\n});\n\nit('用例 5: 输入 255.255.255.255', () => {\n  assert.deepEqual(f('255.255.255.255'), true);\n});\n\nit('用例 6: 输入 192.168.1.-1', () => {\n  assert.deepEqual(f('192.168.1.-1'), false);\n});\n\nit('用例 7: 输入 192.168.1.260', () => {\n  assert.deepEqual(f('192.168.1.260'), false);\n});\n"
    },
    {
      "answermd": "### 方法一\n\n正则表达式\n\n```js\nexport default function isAmount(amount) {\n  return /^(0|[1-9]\\d*)(\\.\\d{1,2})?$/.test(amount);\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "isAmount",
      "answer": "export default function isAmount(amount) {\n  return /^(0|[1-9]\\d*)(\\.\\d{1,2})?$/.test(amount);\n}\n",
      "introduce": "金额合法性判断\n\n合法的金额包含整数以及小数点后不超过两位的小数\n\n用例 1:\n\n```js\nconst amount = '20';\nisAmount(amount); // true\n```\n\n用例 2:\n\n```js\nconst amount = '1.23';\nisAmount(amount); // true\n```\n\n用例 3:\n\n```js\nconst amount = '1.';\nisAmount(amount); // false\n```\n\n用例 4:\n\n```js\nconst amount = '0.2';\nisAmount(amount); // true\n```\n\n用例 5:\n\n```js\nconst amount = '.1';\nisAmount(amount); // false\n```\n\n用例 6:\n\n```js\nconst amount = '02';\nisAmount(amount); // false\n```\n",
      "desc": "金额合法性判断",
      "template": "/**\n * 判断 金额是否合法\n *\n * @export\n * @param {string} amount\n * @return {boolean}\n */\nexport default function isAmount(amount) {\n  return true;\n}\n",
      "test": "import isAmount from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('用例 1: 输入 1.23', () => {\n  assert.equal(isAmount('1.23'), true);\n});\n\nit('用例 2: 输入 256.23', () => {\n  assert.equal(isAmount('256.23'), true);\n});\n\nit('用例 3: 输入 0.23', () => {\n  assert.equal(isAmount('0.23'), true);\n});\n\nit('用例 4: 输入 0.2', () => {\n  assert.equal(isAmount('0.2'), true);\n});\n\nit('用例 5: 输入 0.234', () => {\n  assert.equal(isAmount('0.234'), false);\n});\n\nit('用例 6: 输入 0.', () => {\n  assert.equal(isAmount('0.'), false);\n});\n\nit('用例 7: 输入 .2', () => {\n  assert.equal(isAmount('.2'), false);\n});\n\nit('用例 8: 输入 20', () => {\n  assert.equal(isAmount('20'), true);\n});\n\nit('用例 9: 输入 02', () => {\n  assert.equal(isAmount('02'), false);\n});\n\nit('用例 10: 输入 102', () => {\n  assert.equal(isAmount('102'), true);\n});\n\nit('用例 11: 输入 102.2', () => {\n  assert.equal(isAmount('102.2'), true);\n});\n"
    },
    {
      "answermd": "### 方法一\n\n原生 api sort 方法\n\n```js\nexport default function sort(arr) {\n  // js api\n  return arr.sort();\n}\n```\n\n### 方法二\n\n快速排序\n\n```js\nfunction quicksort(arr, l = 0, r = arr.length - 1) {\n  const t = arr[l];\n\n  if (l >= r) return;\n\n  let _r = r,\n    _l = l;\n\n  while (_l < _r) {\n    while (_r > _l && arr[_r] >= t) {\n      _r--;\n    }\n    while (_l < _r && arr[_l] <= t) {\n      _l++;\n    }\n\n    if (_l < _r) {\n      const temp = arr[_l];\n      arr[_l] = arr[_r];\n      arr[_r] = temp;\n    }\n  }\n\n  arr[l] = arr[_l];\n  arr[_l] = t;\n\n  quicksort(arr, l, _l - 1);\n  quicksort(arr, _r + 1, r);\n  return arr;\n}\n```\n\n### 方法三\n\n冒泡排序\n\n```js\nexport default function sort(arr) {\n  let len = arr.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "sort",
      "answer": "export default function f(arr) {\n  // js api\n  return arr.sort();\n}\n",
      "introduce": "将数组按从小到大的顺序排序\n\n输入为 数字数组\n\n- 冒泡排序\n- 选择排序\n- 插入排序\n- 归并排序\n- 堆排序\n- 快速排序\n\n...\n\n用例 1:\n\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n用例 2:\n\n```js\nconst arr = [1, 9, 2, 4, 3, 7, 6, 8, 6];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n用例 3:\n\n```js\nconst arr = [1, 1, 1, 3, 4, 5, 7, 6, 6, 6, 0, 0, -1];\nconst sortArr = sort(arr);\n\nconsole.log(sortArr); // [-1, 0, 0, 1, 1, 1, 3, 4, 5, 6, 6, 6, 7]\n```\n",
      "desc": "将数组按从小到大的顺序排序",
      "template": "/**\n * 排序函数\n *\n * @export\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function sort(arr) {\n  return [];\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('空数组: 输入 []', () => {\n  assert.deepEqual(f([]), []);\n});\n\nit('已排序好的数组: 输入 [1, 2, 3, 4, 5, 6, 7, 8, 9]', () => {\n  assert.deepEqual(f([1, 2, 3, 4, 5, 6, 7, 8, 9]), [1, 2, 3, 4, 5, 6, 7, 8, 9]);\n});\n\nit('乱序数组一: 输入 [1, 9, 2, 4, 3, 7, 6, 8, 5]', () => {\n  assert.deepEqual(f([1, 9, 2, 4, 3, 7, 6, 8, 5]), [1, 2, 3, 4, 5, 6, 7, 8, 9]);\n});\n\nit('乱序数组二-包含负数: 输入 [1, 1, 1, 3, 4, 5, 7, 6, 6, 6, 0, 0, -1]', () => {\n  assert.deepEqual(\n    f([1, 1, 1, 3, 4, 5, 7, 6, 6, 6, 0, 0, -1]),\n    [-1, 0, 0, 1, 1, 1, 3, 4, 5, 6, 6, 6, 7]\n  );\n});\n"
    },
    {
      "answermd": "### 方法一\n\n利用 set 去除\n\n```js\nexport default function unique(arr) {\n  return [...new Set(arr)];\n}\n```\n",
      "type": 1,
      "level": 1,
      "name": "unique",
      "answer": "export default function unique(arr) {\n  return [...new Set(arr)];\n}\n",
      "introduce": "数组去重\n\n用例 1:\n\n```js\nconst arr = [1, 2, 3];\nconst uniqueArr = unique(arr1);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n\n用例 2:\n\n```js\nconst arr = [1, 2, 3, 3, 3];\nconst uniqueArr = unique(arr);\n\nconsole.log(uniqueArr); // [1, 2, 3]\n```\n",
      "desc": "数组去重",
      "template": "/**\n * 数组去重\n *\n * @export\n * @param {number[]} arr\n * @return {number[]}\n */\nexport default function unique(arr) {\n  return [];\n}\n",
      "test": "import f from './answer.mjs';\nimport { it } from 'mocha';\nimport { assert } from 'chai';\n\nit('无重复数字: 输入 [1, 2, 3]', () => {\n  assert.deepEqual(f([1, 2, 3]), [1, 2, 3]);\n});\n\nit('单个重复数字: 输入 [1, 2, 3, 3]', () => {\n  assert.deepEqual(f([1, 2, 3, 3]), [1, 2, 3]);\n});\n\nit('多个重复数字: 输入 [1, 1, 2, 2, 2, 3, 3]', () => {\n  assert.deepEqual(f([1, 1, 2, 2, 2, 3, 3]), [1, 2, 3]);\n});\n"
    }
  ]
}
